package me.ionar.salhack.module.render;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import me.ionar.salhack.events.client.EventSalHackTick;
import me.ionar.salhack.events.player.EventPlayerUpdate;
import me.ionar.salhack.events.render.RenderEvent;
import me.ionar.salhack.module.Module;
import me.ionar.salhack.module.Value;
import me.ionar.salhack.util.CrystalUtils;
import me.ionar.salhack.util.render.RenderUtil;
import me.ionar.salhack.util.render.ESPUtil.HoleModes;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.culling.Frustum;
import net.minecraft.client.renderer.culling.ICamera;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;

import static me.ionar.salhack.util.render.ESPUtil.Render;
import static org.lwjgl.opengl.GL11.*;

public class VulnerabilityESPModule extends Module
{
    public final Value<Integer> Radius = new Value<Integer>("Radius", new String[] { "Radius", "Range", "Distance" }, "Radius in blocks to scan for blocks.", 5, 0, 32, 1);
    public final Value<Float> MinDMG = new Value<Float>("MinDMG", new String[] {"MinDMG"}, "Visualizes blocks if they do atleast MinDMG to you.", 10.0f);
    
    public final Value<HoleModes> HoleMode = new Value<HoleModes>("Mode", new String[] {"HM"}, "Mode for rendering blocks", HoleModes.Outline);

    public final Value<Float> Red = new Value<Float>("Red", new String[] {"oRed"}, "Red for rendering", 1.0f, 0f, 1.0f, 0.1f);
    public final Value<Float> Green = new Value<Float>("Green", new String[] {"oGreen"}, "Green for rendering", 0.5f, 0f, 1.0f, 0.1f);
    public final Value<Float> Blue = new Value<Float>("Blue", new String[] {"oBlue"}, "Blue for rendering", 0f, 0f, 1.0f, 0.1f);
    public final Value<Float> Alpha = new Value<Float>("Alpha", new String[] {"oAlpha"}, "Alpha for rendering", 0.5f, 0f, 1.0f, 0.1f);

    public VulnerabilityESPModule()
    {
        super("VulnerabilityESP", new String[] {""}, "Highlights blocks that if a crystal is placed and detonated there will do fatal damage to you.", "NONE", -1, ModuleType.RENDER);
    }
    
    private ICamera camera = new Frustum();
    private List<BlockPos> m_AvailableBlockPositions;
    
    @EventHandler
    private Listener<EventSalHackTick> OnSalTick = new Listener<>(p_Event ->
    {
        try
        {
            if (mc.player == null)
                return;
            
            m_AvailableBlockPositions = CrystalUtils.findCrystalBlocks(mc.player, Radius.getValue()).stream()
                    .filter(p_Pos -> TestRequirements(p_Pos)).collect(Collectors.toList());
        }
        catch (Exception e)
        {
            
        }
    });
    
    private boolean TestRequirements(BlockPos p_Pos)
    {
        return CrystalUtils.calculateDamage(mc.world, p_Pos.getX()+0.5, p_Pos.getY()+1.0, p_Pos.getZ()+0.5, mc.player, 0) > MinDMG.getValue();
    }
    
    @EventHandler
    private Listener<RenderEvent> OnRenderEvent = new Listener<>(p_Event ->
    {
        if (mc.getRenderManager() == null || mc.getRenderManager().options == null || m_AvailableBlockPositions == null)
            return;

        new ArrayList<BlockPos>(m_AvailableBlockPositions).forEach(l_Pos ->
        {
            final AxisAlignedBB bb = new AxisAlignedBB(l_Pos.getX() - mc.getRenderManager().viewerPosX,
                    l_Pos.getY() - mc.getRenderManager().viewerPosY, l_Pos.getZ() - mc.getRenderManager().viewerPosZ,
                    l_Pos.getX() + 1 - mc.getRenderManager().viewerPosX,
                    l_Pos.getY() + (1) - mc.getRenderManager().viewerPosY,
                    l_Pos.getZ() + 1 - mc.getRenderManager().viewerPosZ);
    
            camera.setPosition(mc.getRenderViewEntity().posX, mc.getRenderViewEntity().posY,
                    mc.getRenderViewEntity().posZ);
    
            if (camera.isBoundingBoxInFrustum(new AxisAlignedBB(bb.minX + mc.getRenderManager().viewerPosX,
                    bb.minY + mc.getRenderManager().viewerPosY, bb.minZ + mc.getRenderManager().viewerPosZ,
                    bb.maxX + mc.getRenderManager().viewerPosX, bb.maxY + mc.getRenderManager().viewerPosY,
                    bb.maxZ + mc.getRenderManager().viewerPosZ)))
            {
                GlStateManager.pushMatrix();
                GlStateManager.enableBlend();
                GlStateManager.disableDepth();
                GlStateManager.tryBlendFuncSeparate(770, 771, 0, 1);
                GlStateManager.disableTexture2D();
                GlStateManager.depthMask(false);
                glEnable(GL_LINE_SMOOTH);
                glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
                glLineWidth(1.5f);
                Render(HoleMode.getValue(), bb, Red.getValue(), Green.getValue(), Blue.getValue(), Alpha.getValue());
                glDisable(GL_LINE_SMOOTH);
                GlStateManager.depthMask(true);
                GlStateManager.enableDepth();
                GlStateManager.enableTexture2D();
                GlStateManager.disableBlend();
                GlStateManager.popMatrix();
            }
        });
    });
}
